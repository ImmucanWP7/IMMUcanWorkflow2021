colnames(abundances_IMC) <- paste(colnames(abundances_IMC), "IMC")
colnames(abundances_IF) <- paste(colnames(abundances_IF), "mIF")
stopifnot(all.equal(rownames(abundances_IMC), rownames(abundances_IF)))
combined_df <- cbind(abundances_IMC, abundances_IF)
combined_meta <- rbind(meta_IMC, meta_IF)
# DA testing
y.ab <- DGEList(combined_df, samples=combined_meta, group = combined_meta$modality)
# Define the design matrix for the model: Add modality to the model to account for matched design
design <- model.matrix(~sample_id + modality, data = y.ab$samples)
# Estimate NB and QL dispersion
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)
fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
summary(fit.ab$df.prior)
plotQLDisp(fit.ab, cex=1)
# Test for differential abundance of cell types
res <- glmQLFTest(fit.ab, coef=ncol(design))
summary(decideTests(res))
DA <- topTags(res)$table
DA$celltype <- rownames(DA)
DA$sign <- DA$FDR<0.05
DA
# Volcano plot
ggplot(DA) + geom_point(aes(logFC, -log10(FDR), color = sign)) +
geom_label_repel(aes(logFC, -log10(FDR), label = celltype)) +
theme_classic()
# MA plot
(p <- ggplot(DA) + geom_abline(intercept = 0, slope = 0, color = "dark red", lwd = 3) +
geom_point(aes(logCPM, logFC), size = 7) +
geom_point(aes(logCPM, logFC, color = sign), size = 5) +
geom_label_repel(aes(logCPM, logFC, label = celltype), size = 8) +
scale_color_manual(values = c("TRUE" = "dark green", "FALSE" = "white"),
name = "Significance") +
ylab(c("log2 Fold Change")) + xlab("log2 CPM") +
ylim(c(-1.5, 1.5)) +
theme_classic(base_size = 25))
ggsave(filename = "../output/Figure_4/Figure_4B.pdf", plot = p, width = 9, height = 6)
unique(cur_IMC$sample_id)
unique(cur_IMC$patient_id)
library(edgeR)
library(ggrepel)
cur_mIF <- colData(sce_mIF)
cur_IMC <- colData(sce_IMC)
# Count cell types for IMC
abundances_IMC <- unclass(table(cur_IMC$matched_celltype, cur_IMC$sample_id))
# Metdata for IMC
meta_IMC <- data.frame(sample_id = colnames(abundances_IMC),
patient_id = sub("-", "", str_extract(colnames(abundances_IMC), "[0-9]{8}-")),
modality = "IMC")
# Count cell types for mIF
abundances_IF <- unclass(table(cur_mIF$matched_celltype, cur_mIF$sample_id))
# Metadata for mIF
meta_IF <- data.frame(sample_id = colnames(abundances_IF),
patient_id = sub("-", "", str_extract(colnames(abundances_IF), "[0-9]{8}-")),
modality = "mIF")
colnames(abundances_IMC) <- paste(colnames(abundances_IMC), "IMC")
colnames(abundances_IF) <- paste(colnames(abundances_IF), "mIF")
stopifnot(all.equal(rownames(abundances_IMC), rownames(abundances_IF)))
combined_df <- cbind(abundances_IMC, abundances_IF)
combined_meta <- rbind(meta_IMC, meta_IF)
# DA testing
y.ab <- DGEList(combined_df, samples=combined_meta, group = combined_meta$modality)
# Define the design matrix for the model: Add modality to the model to account for matched design
design <- model.matrix(~sample_id + modality, data = y.ab$samples)
# Estimate NB and QL dispersion
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)
fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
summary(fit.ab$df.prior)
plotQLDisp(fit.ab, cex=1)
# Test for differential abundance of cell types
res <- glmQLFTest(fit.ab, coef=ncol(design))
summary(decideTests(res))
DA <- topTags(res)$table
DA$celltype <- rownames(DA)
DA$sign <- DA$FDR<0.1
DA
# Volcano plot
ggplot(DA) + geom_point(aes(logFC, -log10(FDR), color = sign)) +
geom_label_repel(aes(logFC, -log10(FDR), label = celltype)) +
theme_classic()
# MA plot
(p <- ggplot(DA) + geom_abline(intercept = 0, slope = 0, color = "dark red", lwd = 3) +
geom_point(aes(logCPM, logFC), size = 7) +
geom_point(aes(logCPM, logFC, color = sign), size = 5) +
geom_label_repel(aes(logCPM, logFC, label = celltype), size = 8) +
scale_color_manual(values = c("TRUE" = "dark green", "FALSE" = "white"),
name = "Significance") +
ylab(c("log2 Fold Change")) + xlab("log2 CPM") +
ylim(c(-1.5, 1.5)) +
theme_classic(base_size = 25))
ggsave(filename = "../output/Figure_4/Figure_4B.pdf", plot = p, width = 9, height = 6)
DA$sign
library(edgeR)
library(ggrepel)
cur_mIF <- colData(sce_mIF)
cur_IMC <- colData(sce_IMC)
# Count cell types for IMC
abundances_IMC <- unclass(table(cur_IMC$matched_celltype, cur_IMC$sample_id))
# Metdata for IMC
meta_IMC <- data.frame(sample_id = colnames(abundances_IMC),
patient_id = sub("-", "", str_extract(colnames(abundances_IMC), "[0-9]{8}-")),
modality = "IMC")
# Count cell types for mIF
abundances_IF <- unclass(table(cur_mIF$matched_celltype, cur_mIF$sample_id))
# Metadata for mIF
meta_IF <- data.frame(sample_id = colnames(abundances_IF),
patient_id = sub("-", "", str_extract(colnames(abundances_IF), "[0-9]{8}-")),
modality = "mIF")
colnames(abundances_IMC) <- paste(colnames(abundances_IMC), "IMC")
colnames(abundances_IF) <- paste(colnames(abundances_IF), "mIF")
stopifnot(all.equal(rownames(abundances_IMC), rownames(abundances_IF)))
combined_df <- cbind(abundances_IMC, abundances_IF)
combined_meta <- rbind(meta_IMC, meta_IF)
# DA testing
y.ab <- DGEList(combined_df, samples=combined_meta, group = combined_meta$modality)
# Define the design matrix for the model: Add modality to the model to account for matched design
design <- model.matrix(~sample_id + modality, data = y.ab$samples)
# Estimate NB and QL dispersion
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)
fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
summary(fit.ab$df.prior)
plotQLDisp(fit.ab, cex=1)
# Test for differential abundance of cell types
res <- glmQLFTest(fit.ab, coef=ncol(design))
summary(decideTests(res))
DA <- topTags(res)$table
DA$celltype <- rownames(DA)
DA$sign <- DA$FDR<0.05
DA
# Volcano plot
ggplot(DA) + geom_point(aes(logFC, -log10(FDR), color = sign)) +
geom_label_repel(aes(logFC, -log10(FDR), label = celltype)) +
theme_classic()
# MA plot
(p <- ggplot(DA) + geom_abline(intercept = 0, slope = 0, color = "dark red", lwd = 3) +
geom_point(aes(logCPM, logFC), size = 7) +
geom_point(aes(logCPM, logFC, color = sign), size = 5) +
geom_label_repel(aes(logCPM, logFC, label = celltype), size = 8) +
scale_color_manual(values = c("TRUE" = "dark green", "FALSE" = "white"),
name = "Significance") +
ylab(c("log2 Fold Change")) + xlab("log2 CPM") +
ylim(c(-1.5, 1.5)) +
theme_classic(base_size = 25))
ggsave(filename = "../output/Figure_4/Figure_4B.pdf", plot = p, width = 9, height = 6)
getwd()
!dir.exists("../output/Figure_4/")
hist(sce_IMC$area)
hist(sce_mIF$area)
hist(sce_mIF$cell.area)
# Chunk 1
# Set path
if (Sys.info()["sysname"] == "Windows"){
mount_path <- "O:/projects/immucan/"
} else {
mount_path <- "/Volumes/G_DQBM_BB_Central$/projects/immucan"
}
# Chunk 2
library(SingleCellExperiment)
library(tidyverse)
library(ggpubr)
library(cowplot)
library(imcRtools)
sce_IMC <- readRDS(file.path(mount_path, "processed_data/Panel_1/2022_WORKFLOW/IMC/Rout/sce.rds"))
sce_mIF <- readRDS(file.path(mount_path, "processed_data/Panel_1/2022_WORKFLOW/mIF/Rout/sce_ROIs.rds"))
# Chunk 3: prepare-data
# Prepare mIF data
cur_mIF <- sce_mIF
colData(cur_mIF) <- colData(cur_mIF)[,c("sample_id", "patient_id", "nucleus.x", "nucleus.y", "matched_celltype", "tissue.type", "TLS.ID")]
cur_mIF$Pos_X <- cur_mIF$nucleus.x
cur_mIF$Pos_Y <- cur_mIF$nucleus.y
cur_mIF$Pos_X <- cur_mIF$Pos_X * 0.4962
cur_mIF$Pos_Y <- cur_mIF$Pos_Y * 0.4962
cur_mIF$nucleus.x <- NULL
cur_mIF$nucleus.y <- NULL
rowData(cur_mIF) <- NULL
assays(cur_mIF) <- list()
metadata(cur_mIF) <- list()
rownames(cur_mIF) <- NULL
colPairs(cur_mIF) <- NULL
cur_mIF$modality <- "mIF"
# Prepare IMC data
cur_IMC <- sce_IMC
colData(cur_IMC) <- colData(cur_IMC)[,c("sample_id", "patient_id", "matched_celltype", "Pos_X", "Pos_Y")]
cur_IMC$tissue.type <- c("stroma", "tumor")[as.numeric(sce_IMC$tumor_patches) + 1]
cur_IMC$TLS.ID <- sce_IMC$CD20_patches
rowData(cur_IMC) <- NULL
assays(cur_IMC) <- list()
metadata(cur_IMC) <- list()
rownames(cur_IMC) <- NULL
reducedDims(cur_IMC) <- NULL
colPairs(cur_IMC) <- NULL
cur_IMC$modality <- "IMC"
# Merge data
all_sce <- cbind(cur_IMC[1:6,], cur_mIF)
all_sce$sample_id_global <- paste0(all_sce$sample_id, "_", all_sce$modality)
# Chunk 4
if (!dir.exists("output/Figure_S6/")) dir.create("output/Figure_S6/")
all_sce$CD20_logical <- !is.na(all_sce$TLS.ID)
p <- plotSpatial(all_sce[,all_sce$modality == "IMC"],
node_color_by = "CD20_logical",
ncols = 4, img_id = "sample_id")
ggsave(filename = "output/Figure_S6/FigS6_IMC.pdf", plot = p, width = 20, height = 49)
p <- plotSpatial(all_sce[,all_sce$modality == "mIF"],
node_color_by = "CD20_logical",
ncols = 4, img_id = "sample_id")
ggsave(filename = "output/Figure_S6/FigS6_mIF.pdf", plot = p, width = 20, height = 49)
library(sf)
library(spatstat)
?mad.test
# Example image
cur_sce <- all_sce[,all_sce$sample_id == "IMMUcan_Batch20210921_10082495-SPECT-VAR-TIS-01-IMC-01_004"]
cur_sce <- cur_sce[,cur_sce$matched_celltype == "Tumor"] which
# Example image
cur_sce <- all_sce[,all_sce$sample_id == "IMMUcan_Batch20210921_10082495-SPECT-VAR-TIS-01-IMC-01_004"]
cur_sce <- cur_sce[,cur_sce$matched_celltype == "Tumor"]
plotSpatial(cur_sce, node_color_by = "modality", img_id = "sample_id", flip_y = TRUE)
# Create multipoint pattern
cur_ppp <- ppp(x = cur_sce$Pos_X, y = cur_sce$Pos_Y,
xrange = c(0, max(cur_sce$Pos_X)), yrange = c(0, max(cur_sce$Pos_Y)),
marks = factor(cur_sce$modality, levels = c("IMC", "mIF")))
plot(cur_ppp)
miplot(cur_ppp)
#plot(frypoints(cur_ppp))
cur_L <- Lcross(cur_ppp, "IMC", "mIF")
plot(cur_L)
cur_L_inhom <- Lcross.inhom(cur_ppp, "IMC", "mIF")
plot(cur_L_inhom)
cur_env <- envelope(cur_ppp, Lcross, i = "mIF", j = "IMC", fix.n = TRUE, fix.marks = TRUE)
plot(cur_env)
cur_env <- envelope(cur_ppp, Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE, alternative = "greater")
plot(cur_env)
cur_test <- mad.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
cur_test <- dclf.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
cur_test <- mad.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE, alternative = "greater")
cur_test <- mad.sigtrace(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
plot(cur_test)
cur_test <- mad.progress(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
plot(cur_test)
cur_env_inhom <- envelope(cur_ppp, Lcross.inhom, i = "IMC", j = "mIF")
plot(cur_env_inhom)
cur_test_inhom <- mad.test(cur_ppp, fun = Lcross.inhom, i = "IMC", j = "mIF", rinterval = c(0, 100))
# TODO set fix.n and fix.marks to TRUE in the functions below
cur_test
plot(cur_test)
plot(cur_env)
plot(cur_L_inhom)
cur_test_inhom
plot(cur_L)
plot(cur_L_inhom)
cur_test_inhom
plot(cur_env_inhom)
plot(cur_L_inhom)
# Example image
cur_sce <- all_sce[,all_sce$sample_id == "IMMUcan_Batch20210921_10082495-SPECT-VAR-TIS-01-IMC-01_004"]
cur_sce <- cur_sce[,cur_sce$matched_celltype == "Tumor"]
plotSpatial(cur_sce, node_color_by = "modality", img_id = "sample_id", flip_y = TRUE)
# Create multipoint pattern
cur_ppp <- ppp(x = cur_sce$Pos_X, y = cur_sce$Pos_Y,
xrange = c(0, max(cur_sce$Pos_X)), yrange = c(0, max(cur_sce$Pos_Y)),
marks = factor(cur_sce$modality, levels = c("IMC", "mIF")))
plot(cur_ppp)
miplot(cur_ppp)
#plot(frypoints(cur_ppp))
cur_L <- Lcross(cur_ppp, "IMC", "mIF")
plot(cur_L)
cur_L_inhom <- Lcross.inhom(cur_ppp, "IMC", "mIF")
plot(cur_L_inhom)
cur_env <- envelope(cur_ppp, Lcross, i = "mIF", j = "IMC", fix.n = TRUE, fix.marks = TRUE)
plot(cur_env)
cur_env <- envelope(cur_ppp, Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE, alternative = "greater")
plot(cur_env)
cur_test <- mad.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
cur_test <- dclf.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
cur_test <- mad.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE, alternative = "greater")
cur_test <- mad.sigtrace(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
plot(cur_test)
cur_test <- mad.progress(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", fix.n = TRUE, fix.marks = TRUE)
plot(cur_test)
cur_env_inhom <- envelope(cur_ppp, Lcross.inhom, i = "IMC", j = "mIF")
plot(cur_env_inhom)
cur_test_inhom <- mad.test(cur_ppp, fun = Lcross.inhom, i = "IMC", j = "mIF", rinterval = c(0, 100))
# TODO set fix.n and fix.marks to TRUE in the functions below
cur_L$theo
plot(cur_L$theo)
cur_test_inhom
cur_test
cur_test
cur_test <- mad.test(cur_ppp, fun = Lcross, i = "IMC", j = "mIF", rinterval = c(0, 100))
cur_test
knitr::opts_chunk$set(echo = TRUE)
library(SingleCellExperiment)
library(scater)
library(pheatmap)
library(ComplexHeatmap)
library(viridis)
spe <- readRDS("C:/Users/dschulz/Downloads/spe.rds/spe.rds")
spe <- readRDS("D:/Data/data_downlaoded_to_fix_issues_on_github/imcdataanalysis/94/spe/spe.rds")
colData(spe)
celltype_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),
ids = spe$cluster_celltype,
statistics = "mean",
use.assay.type = "exprs",
subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])
spe$cluster_celltype
spe <- readRDS("D:/Data/data_downlaoded_to_fix_issues_on_github/imcdataanalysis/95/spe/spe.rds")
spe <- readRDS("D:/Data/data_downlaoded_to_fix_issues_on_github/imcdataanalysis/95/spe.rds/spe.rds")
celltype_mean <- aggregateAcrossCells(as(spe, "SingleCellExperiment"),
ids = spe$cluster_celltype,
statistics = "mean",
use.assay.type = "exprs",
subset.row = rownames(spe)[rowData(spe)$marker_class == "type"])
h_type <- Heatmap(t(assay(celltype_mean, "exprs")),
column_title = "type_markers",
col =viridis(100),
name= "mean exprs",
show_row_names = TRUE,
show_column_names = TRUE)
draw(h_type)
plotSpatial(spe, img_id = "sample_id",node_color_by = "cluster_celltype")
library(imcRtools)
plotSpatial(spe, img_id = "sample_id",node_color_by = "cluster_celltype")
spe <- detectCommunity(spe,
colPairName = "neighborhood",
size_threshold = 3)
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "neighborhood",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
colPair(spe, "neighborhood")
spe <- detectCommunity(spe,
colPairName = "neighborhood",
size_threshold = 10)
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "neighborhood",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
plotSpatial(spe,
node_color_by = "spatial_community",
img_id = "sample_id",
node_size_fix = 0.5) +
theme(legend.position = "none") +
ggtitle("Spatial tumor communities") +
scale_color_manual(values = rev(colors()))
plotSpatial(spe,
node_color_by = "spatial_community",
img_id = "sample_id",
node_size_fix = 0.5) +
theme(legend.position = "none") +
ggtitle("Spatial tumor communities") +
scale_color_manual(values = rev(colors()))
spe <- detectCommunity(spe,
colPairName = "neighborhood",
size_threshold = 3)
plotSpatial(spe,
node_color_by = "spatial_community",
img_id = "sample_id",
node_size_fix = 0.5) +
theme(legend.position = "none") +
ggtitle("Spatial tumor communities") +
scale_color_manual(values = rev(colors()))
(spe$spatial_community)
unique(spe$spatial_community)
spe <- detectCommunity(spe,
colPairName = "neighborhood",
size_threshold = 10)
unique(spe$spatial_community)
hist(spe$area)
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "neighborhood",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "neighborhood",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
dat <- (colPari(spe, "neighborhood"))
dat <- (colPari(spe, "neighborhood")
dat <- (colPair(spe, "neighborhood")
)
dat
unique(dat$from)
dat <- as.data.frame(dat)
dat
unique(dat$from)
ncol(spe)
dim(dat)
hist(spe$axis_major_length)
mean(spe$axis_major_length)
spe <- buildSpatialGraph(spe,img_id = "sample_id",type = "expansion",k = 16)
spe <- buildSpatialGraph(spe,img_id = "sample_id",type = "expansion",threshold = 16)
colPairs(spe)
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "expansion_interaction_graph",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
spe <- buildSpatialGraph(spe,img_id = "sample_id",type = "expansion",threshold = 25)
# delaunay interaction graph
plotSpatial(spe,
node_color_by = "cluster_celltype",
img_id = "sample_id",
draw_edges = TRUE,
colPairName = "expansion_interaction_graph",
nodes_first = FALSE,
edge_color_fix = "grey") +
ggtitle("delaunay interaction graph")
colPair(spe, "expansion_interaction_graph")
colPair(spe, "knn_interaction_graph")
?buildSpatialGraph
spe <- readRDS("D:/Data/data_downlaoded_to_fix_issues_on_github/imcdataanalysis/94/spe/spe.rds")
cm <- confusionMatrix(data = cur_pred,reference = factor(test_spe$cell_labels),mode = "everything")
library(caret)
cm <- confusionMatrix(data = cur_pred,reference = factor(test_spe$cell_labels),mode = "everything")
spe$cell_labels
table(spe$cell_labels)
# Split between labeled and unlabeled cells
lab_spe <- spe[,spe$cell_labels != "unlabeled"]
unlab_spe <- spe[,spe$cell_labels == "unlabeled"]
unlab_spe
# Randomly split into train and test data
set.seed(221029)
trainIndex <- createDataPartition(factor(lab_spe$cell_labels), p = 0.75)
train_spe <- lab_spe[,trainIndex$Resample1]
test_spe <- lab_spe[,-trainIndex$Resample1]
train_spe
unique(train_spe$cell_labels)
table(train_spe$cell_labels)
table(test$cell_labels)
table(test_spe$cell_labels)
# Define fit parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
number = 5)
cur_mat <- t(assay(train_spe, "exprs")[rowData(train_spe)$use_channel,])
# Train a random forest classifier
rffit <- train(x = cur_mat,
y = factor(train_spe$cell_labels),
method = "rf", ntree = 1000,
tuneLength = 5,
trControl = fitControl)
rffit
# Select the arsinh-transformed counts of the test data
cur_mat <- t(assay(test_spe, "exprs")[rowData(test_spe)$use_channel,])
# Predict the cell phenotype labels of the test data
set.seed(231019)
cur_pred <- predict(rffit, newdata = cur_mat)
cm <- confusionMatrix(data = cur_pred,
reference = factor(test_spe$cell_labels),
mode = "everything")
cur_pred
cur_pred
table(cur_pred)
table(factor(test_spe$cell_labels))
table(cur_pred)
table(factor(test_spe$cell_labels))
cm <- confusionMatrix(data = cur_pred,
reference = factor(test_spe$cell_labels),
mode = "everything")
cur_pred <- cur_pred[!cur_pred == "Metastasis"]
cm <- confusionMatrix(data = cur_pred,
reference = factor(test_spe$cell_labels),
mode = "everything")
cur_pred
table(cur_pred)
table(cur_pred[!cur_pred == "Metastasis"])
cur_pred == "Metastasis"
sum(cur_pred == "Metastasis")
levels(cur_pred)
levels(factor(test_spe$cell_labels))
levels(cur_pred) <- levels(cur_pred)[c(1:3,5:11)]
levels(cur_pred
levels(cur_pred)
levels(cur_pred)
c(1:3,5:11)
levels(cur_pred)[c(1:3,5:11)]
levels(cur_pred) <- levels(cur_pred)[c(1:3,5:11)]
length(levels(cur_pred))
length8cur_pred
length(cur_pred)
table(train_spe$cell_labels)
table(test_spe$cell_labels)
